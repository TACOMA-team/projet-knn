Belief function theory in java
==============================

This library implements the belief function theory.

Getting started
===============

Creating a belief function
----------------------------

~~~{.java}
//imports:
import fr.inria.tacoma.bft.core.frame.FrameOfDiscernment;
import fr.inria.tacoma.bft.core.mass.MassFunction;
import fr.inria.tacoma.bft.core.mass.MassFunctionImpl;
/*
 * . . .
 */
//creates a new frame of discernment. The first parameter is the name of
// our frame (presence, posture, color...) the next parameters are the
// different states for our frame
FrameOfDiscernment frame = FrameOfDiscernment.newFrame("position",
"standing", "sitting", "layingDown");
//creates a new mass function
//Firstly, we create an empty mass function, we then attribute mass to
// state sets
MassFunction massFunction = new MassFunctionImpl(frame);
massFunction.addToFocal(frame.toStateSet("sitting"), 0.2);
massFunction.addToFocal(frame.toStateSet("sitting", "layingDown"), 0.3);
massFunction.putRemainingOnIgnorance();
~~~


Fusing belief functions
-----------------------

Currently, only Dempster combination and Dubois and Prade combinations are implemented.
These combination are available in Combinations as static functions.

~~~{.java}
//creates a new frame of discernment. The parameters are the different states for our frame
MassFunction combinedWithDempster = Combinations.dempster(mass1, mass2);
MassFunction combinedWithDuboisAndPrade = Combinations.duboisAndPrade(mass1, mass2);
~~~

A note about toString()
-----------------------

Classes in _fr.inria.tacoma.bft.core_ override toString. This will return a valid json
string. This string does not however contains every piece of information necessary
to rebuild the original object. For instance, MassFunction.toString() will print
something like:

~~~
{"focals": [{"set": ["layingDown", "sitting", "standing"], "value": 0.5},
{"set": ["layingDown", "sitting"], "value": 0.3},{"set": ["sitting"], "value": 0.2} ]}
~~~

From sensor data to beliefs
===========================

You can create a model which will map sensor values to mass functions. Three types
of models are currently implemented. They all implement the interface SensorBeliefModel.
The linear sensor belief model is a simple model with no memory while specificity model
and fusion model remember the previous call and can use previous evidences from sensor
in new mass functions. These temporization methods are described in
Belief inference with timed evidence (B Pietropaoli, M Dominici, F Weis).

__LinearSensorBeliefModel__: This model is the most important. It works by mapping mass
    function to specific sensor values. Between those values, the mass function are
    generated by linear interpolation.

__SpecificitySensorBeliefModel__: This model is time dependant and remember the last mass
function it returned. When calling toMassFunction for the first time, it wil behave like
a LinearSensorBeliefModel. When the toMassFunction method is called a second time, It weaken
the previous mass function and chooses between the previous weakened function and the new
generated with a linear model. The criterion for choosing is specificity.

__FusionSensorBeliefModel__: As specificity model, this model remember the last mass function
and uses an underlying linear model. Instead of choosing between two function, it combines
the weakened old function and the new function to creates the resulting mass function.

Creating a model programmatically
---------------------------------

~~~{.java}
SensorBeliefModel model = new LinLinearSensorBeliefModel(frame);
//for the value 100.0, we consider that the person is sitting with 1.0 as mass
baseModel.addInterpolationPoint(100.0, frame.toStateSet("sitting"), 1.0);
//for the value 200.0, we consider that the person is sitting or standing with 1.0 as mass
baseModel.addInterpolationPoint(200.0, frame.toStateSet("sitting", "standing"), 1.0);
//this will return a mass function such as {{sitting} => 0.5, {sitting, standing} => 0.5}
baseModel.toMassFunction(150.0);
~~~

Other sensors model takes a base model as argument, typically a linear sensor model.

~~~{.java}
SensorBeliefModel specificityModel = SpecificitySensorBeliefModel(baseModel, 1.0);
~~~

Creating a model from xml
-------------------------

It is possible to create a belief model directly from an xml file.
The xml files have the following syntax:

~~~{.xml}
<belief-from-sensors>
    <!-- First we declare the frame of discernment -->
    <frame name="myName">
        <state>A</state>
        <state>B</state>
        <state>C</state>
    </frame>

    <!--
    Then we declare the different models we'll be using as sets of belief
    functions.
    -->
    <sensor-beliefs>
        <!--
        We give a name for the set of belief function which will be an
        id for this model.
        -->
        <sensor-belief name="Sensor1Set">

            <!-- Options for this model. This tag is optional. -->
            <options>
            <!--
            An option is defined by a name and a value, The current available
            options are "tempo-specificity" and "tempo-fusion". These options
            are not compatible so currently, only one option can be put
            in the options tag. The value inside this tag is the time for an
            old evidence to be forgotten (see FusionSensorBeliefModel and
            SpecificitySensorBeliefModel classes).
            -->
                <option name="tempo-specificity">1</option>
            </options>

            <point>
                <!--
                Each point needs a value tag to tell which sensor value maps
                to the mass function. Then a mass is assigned for each set
                -->
                <value>100.0</value>
                <mass set="B">0.75</mass>
                <mass set="C">0.25</mass>
                <mass set="A B">0.0</mass>
            </point>
            <point>
                <value>200.0</value>
                <mass set="A">0.25</mass>
                <mass set="B">0.5</mass>
                <mass set="C">0.10</mass>
                <mass set="A B">0.15</mass>
            </point>
            <point>
                <value>300.0</value>
                <mass set="A">0.75</mass>
                <mass set="B">0.10</mass>
                <mass set="A B">0.15</mass>
            </point>
        </sensor-belief>
        <sensor-belief name="Sensor2Set">
            <point>
                <value>300.0</value>
                <mass set="A">0.75</mass>
                <mass set="B">0.10</mass>
                <mass set="A B">0.15</mass>
            </point>
            <point>
                <value>400.0</value>
                <mass set="A">0.25</mass>
                <mass set="B">0.5</mass>
                <mass set="C">0.1</mass>
                <mass set="A B">0.15</mass>
            </point>
            <point>
                <value>500.0</value>
                <mass set="A">0.0</mass>
                <mass set="B">0.75</mass>
                <mass set="C">0.25</mass>
                <mass set="A B">0.0</mass>
            </point>
        </sensor-belief>
    </sensor-beliefs>

    <!-- Then we declare our sensor which will be using these models. -->
    <sensors>
        <sensor name="S1" belief="Sensor1Set" />
        <sensor name="S2" belief="Sensor1Set" />
        <sensor name="S3" belief="Sensor2Set" />
    </sensors>

</belief-from-sensors>
~~~

Decision making
---------------
The package fr.inria.tacoma.bft.decision contains classes used for decision
making. Only one decision algorithm is implemented right now. This algorithm
was described by Pietropaoli in [1]. It aims to find a tradeoff between
precision and confidence by using the 3 common criteria belief betP and
plausibility.

The user has to provide a minimum for each criteria which must be lower than 1.
The algorithm first considers the elements of the powerset with card = 1. If no
element matches the minima, then the algorithm considers the elements with
card = 2 and so on. The algorithm will always stop as the criteria increase
with cardinal and they all give 1 for the frame of discernment.

Code example: 

~~~{.java}
double minBelief = 0.4;
double minbetP = 0.4;
double minPlausibility = 0.4;
DecisionStrategy decisionStrategy = new CriteriaDecisionStrategy(minBelief,
        minbetP, minPlausibility, Criteria::betP);
Decision decision = decisionStrategy.decide(myFusedMassFunction);
System.out.println("confidence: " + decision.getConfidence());
System.out.println("stateSet: " + decision.getStateSet());
~~~


[1] M. Dominici, B. Pietropaoli and F. Weis, 'Experiences in managing uncertainty
and ignorance in a lightly instrumented smart home', Int J of Pervasive Comp &
Comm, vol. 8, no. 3, pp. 225-249, 2012.